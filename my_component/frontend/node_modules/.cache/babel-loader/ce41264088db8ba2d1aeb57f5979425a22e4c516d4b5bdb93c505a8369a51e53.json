{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from './vector.mjs';\nimport { makeData } from './data.mjs';\nimport { MapRow, kKeys } from './row/map.mjs';\nimport { strideForType } from './type.mjs';\nimport { createIsValidFunction } from './builder/valid.mjs';\nimport { BitmapBufferBuilder, DataBufferBuilder, OffsetsBufferBuilder } from './builder/buffer.mjs';\n/**\n * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.\n *\n * A `Builder` is responsible for writing arbitrary JavaScript values\n * to ArrayBuffers and/or child Builders according to the Arrow specification\n * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.\n *\n * The `Builder` for each Arrow `DataType` handles converting and appending\n * values for a given `DataType`. The high-level {@link makeBuilder `makeBuilder()`} convenience\n * method creates the specific `Builder` subclass for the supplied `DataType`.\n *\n * Once created, `Builder` instances support both appending values to the end\n * of the `Builder`, and random-access writes to specific indices\n * (`Builder.prototype.append(value)` is a convenience method for\n * `builder.set(builder.length, value)`). Appending or setting values beyond the\n * Builder's current length may cause the builder to grow its underlying buffers\n * or child Builders (if applicable) to accommodate the new values.\n *\n * After enough values have been written to a `Builder`, `Builder.prototype.flush()`\n * will commit the values to the underlying ArrayBuffers (or child Builders). The\n * internal Builder state will be reset, and an instance of `Data<T>` is returned.\n * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return\n * an instance of `Vector<T>` instead.\n *\n * When there are no more values to write, use `Builder.prototype.finish()` to\n * finalize the `Builder`. This does not reset the internal state, so it is\n * necessary to call `Builder.prototype.flush()` or `toVector()` one last time\n * if there are still values queued to be flushed.\n *\n * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,\n * because this is when it flushes the values that have been enqueued in its internal\n * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.\n *\n * @example\n * ```ts\n * import { Builder, Utf8 } from 'apache-arrow';\n *\n * const utf8Builder = makeBuilder({\n *     type: new Utf8(),\n *     nullValues: [null, 'n/a']\n * });\n *\n * utf8Builder\n *     .append('hello')\n *     .append('n/a')\n *     .append('world')\n *     .append(null);\n *\n * const utf8Vector = utf8Builder.finish().toVector();\n *\n * console.log(utf8Vector.toJSON());\n * // > [\"hello\", null, \"world\", null]\n * ```\n *\n * @typeparam T The `DataType` of this `Builder`.\n * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n */\nexport class Builder {\n  /**\n   * Construct a builder with the given Arrow DataType with optional null values,\n   * which will be interpreted as \"null\" when set or appended to the `Builder`.\n   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\n   */\n  constructor({\n    'type': type,\n    'nullValues': nulls\n  }) {\n    /**\n     * The number of values written to the `Builder` that haven't been flushed yet.\n     * @readonly\n     */\n    this.length = 0;\n    /**\n     * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.\n     * @readonly\n     */\n    this.finished = false;\n    this.type = type;\n    this.children = [];\n    this.nullValues = nulls;\n    this.stride = strideForType(type);\n    this._nulls = new BitmapBufferBuilder();\n    if (nulls && nulls.length > 0) {\n      this._isValid = createIsValidFunction(nulls);\n    }\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughDOM(options) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /**\n   * Flush the `Builder` and return a `Vector<T>`.\n   * @returns {Vector<T>} A `Vector<T>` of the flushed values.\n   */\n  toVector() {\n    return new Vector([this.flush()]);\n  }\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  get nullCount() {\n    return this._nulls.numInvalid;\n  }\n  get numChildren() {\n    return this.children.length;\n  }\n  /**\n   * @returns The aggregate length (in bytes) of the values that have been written.\n   */\n  get byteLength() {\n    let size = 0;\n    const {\n      _offsets,\n      _values,\n      _nulls,\n      _typeIds,\n      children\n    } = this;\n    _offsets && (size += _offsets.byteLength);\n    _values && (size += _values.byteLength);\n    _nulls && (size += _nulls.byteLength);\n    _typeIds && (size += _typeIds.byteLength);\n    return children.reduce((size, child) => size + child.byteLength, size);\n  }\n  /**\n   * @returns The aggregate number of rows that have been reserved to write new values.\n   */\n  get reservedLength() {\n    return this._nulls.reservedLength;\n  }\n  /**\n   * @returns The aggregate length (in bytes) that has been reserved to write new values.\n   */\n  get reservedByteLength() {\n    let size = 0;\n    this._offsets && (size += this._offsets.reservedByteLength);\n    this._values && (size += this._values.reservedByteLength);\n    this._nulls && (size += this._nulls.reservedByteLength);\n    this._typeIds && (size += this._typeIds.reservedByteLength);\n    return this.children.reduce((size, child) => size + child.reservedByteLength, size);\n  }\n  get valueOffsets() {\n    return this._offsets ? this._offsets.buffer : null;\n  }\n  get values() {\n    return this._values ? this._values.buffer : null;\n  }\n  get nullBitmap() {\n    return this._nulls ? this._nulls.buffer : null;\n  }\n  get typeIds() {\n    return this._typeIds ? this._typeIds.buffer : null;\n  }\n  /**\n   * Appends a value (or null) to this `Builder`.\n   * This is equivalent to `builder.set(builder.length, value)`.\n   * @param {T['TValue'] | TNull } value The value to append.\n   */\n  append(value) {\n    return this.set(this.length, value);\n  }\n  /**\n   * Validates whether a value is valid (true), or null (false)\n   * @param {T['TValue'] | TNull } value The value to compare against null the value representations\n   */\n  isValid(value) {\n    return this._isValid(value);\n  }\n  /**\n   * Write a value (or null-value sentinel) at the supplied index.\n   * If the value matches one of the null-value representations, a 1-bit is\n   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\n   * the null `BitmapBufferBuilder`, and the value is passed to\n   * `Builder.prototype.setValue()`.\n   * @param {number} index The index of the value to write.\n   * @param {T['TValue'] | TNull } value The value to write at the supplied index.\n   * @returns {this} The updated `Builder` instance.\n   */\n  set(index, value) {\n    if (this.setValid(index, this.isValid(value))) {\n      this.setValue(index, value);\n    }\n    return this;\n  }\n  /**\n   * Write a value to the underlying buffers at the supplied index, bypassing\n   * the null-value check. This is a low-level method that\n   * @param {number} index\n   * @param {T['TValue'] | TNull } value\n   */\n  setValue(index, value) {\n    this._setValue(this, index, value);\n  }\n  setValid(index, valid) {\n    this.length = this._nulls.set(index, +valid).length;\n    return valid;\n  }\n  // @ts-ignore\n  addChild(child, name = `${this.numChildren}`) {\n    throw new Error(`Cannot append children to non-nested type \"${this.type}\"`);\n  }\n  /**\n   * Retrieve the child `Builder` at the supplied `index`, or null if no child\n   * exists at that index.\n   * @param {number} index The index of the child `Builder` to retrieve.\n   * @returns {Builder | null} The child Builder at the supplied index or null.\n   */\n  getChildAt(index) {\n    return this.children[index] || null;\n  }\n  /**\n   * Commit all the values that have been written to their underlying\n   * ArrayBuffers, including any child Builders if applicable, and reset\n   * the internal `Builder` state.\n   * @returns A `Data<T>` of the buffers and children representing the values written.\n   */\n  flush() {\n    let data;\n    let typeIds;\n    let nullBitmap;\n    let valueOffsets;\n    const {\n      type,\n      length,\n      nullCount,\n      _typeIds,\n      _offsets,\n      _values,\n      _nulls\n    } = this;\n    if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {\n      // Unions\n      // DenseUnions\n      valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);\n    } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {\n      // Variable-width primitives (Binary, Utf8), and Lists\n      // Binary, Utf8\n      data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());\n    } else {\n      // Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, and Interval)\n      data = _values === null || _values === void 0 ? void 0 : _values.flush(length);\n    }\n    if (nullCount > 0) {\n      nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);\n    }\n    const children = this.children.map(child => child.flush());\n    this.clear();\n    return makeData({\n      type,\n      length,\n      nullCount,\n      children,\n      'child': children[0],\n      data,\n      typeIds,\n      nullBitmap,\n      valueOffsets\n    });\n  }\n  /**\n   * Finalize this `Builder`, and child builders if applicable.\n   * @returns {this} The finalized `Builder` instance.\n   */\n  finish() {\n    this.finished = true;\n    for (const child of this.children) child.finish();\n    return this;\n  }\n  /**\n   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\n   * @returns {this} The cleared `Builder` instance.\n   */\n  clear() {\n    var _a, _b, _c, _d;\n    this.length = 0;\n    (_a = this._nulls) === null || _a === void 0 ? void 0 : _a.clear();\n    (_b = this._values) === null || _b === void 0 ? void 0 : _b.clear();\n    (_c = this._offsets) === null || _c === void 0 ? void 0 : _c.clear();\n    (_d = this._typeIds) === null || _d === void 0 ? void 0 : _d.clear();\n    for (const child of this.children) child.clear();\n    return this;\n  }\n}\nBuilder.prototype.length = 1;\nBuilder.prototype.stride = 1;\nBuilder.prototype.children = null;\nBuilder.prototype.finished = false;\nBuilder.prototype.nullValues = null;\nBuilder.prototype._isValid = () => true;\n/** @ignore */\nexport class FixedWidthBuilder extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);\n  }\n  setValue(index, value) {\n    const values = this._values;\n    values.reserve(index - values.length + 1);\n    return super.setValue(index, value);\n  }\n}\n/** @ignore */\nexport class VariableWidthBuilder extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._pendingLength = 0;\n    this._offsets = new OffsetsBufferBuilder();\n  }\n  setValue(index, value) {\n    const pending = this._pending || (this._pending = new Map());\n    const current = pending.get(index);\n    current && (this._pendingLength -= current.length);\n    this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;\n    pending.set(index, value);\n  }\n  setValid(index, isValid) {\n    if (!super.setValid(index, isValid)) {\n      (this._pending || (this._pending = new Map())).set(index, undefined);\n      return false;\n    }\n    return true;\n  }\n  clear() {\n    this._pendingLength = 0;\n    this._pending = undefined;\n    return super.clear();\n  }\n  flush() {\n    this._flush();\n    return super.flush();\n  }\n  finish() {\n    this._flush();\n    return super.finish();\n  }\n  _flush() {\n    const pending = this._pending;\n    const pendingLength = this._pendingLength;\n    this._pendingLength = 0;\n    this._pending = undefined;\n    if (pending && pending.size > 0) {\n      this._flushPending(pending, pendingLength);\n    }\n    return this;\n  }\n}","map":{"version":3,"names":["Vector","makeData","MapRow","kKeys","strideForType","createIsValidFunction","BitmapBufferBuilder","DataBufferBuilder","OffsetsBufferBuilder","Builder","constructor","type","nulls","length","finished","children","nullValues","stride","_nulls","_isValid","throughNode","options","Error","throughDOM","toVector","flush","ArrayType","nullCount","numInvalid","numChildren","byteLength","size","_offsets","_values","_typeIds","reduce","child","reservedLength","reservedByteLength","valueOffsets","buffer","values","nullBitmap","typeIds","append","value","set","isValid","index","setValid","setValue","_setValue","valid","addChild","name","getChildAt","data","last","map","clear","finish","_a","_b","_c","_d","prototype","FixedWidthBuilder","opts","reserve","VariableWidthBuilder","_pendingLength","pending","_pending","Map","current","get","undefined","_flush","pendingLength","_flushPending"],"sources":["/Users/lfoppiano/development/projects/streamlit-pdf-component/my_component/frontend/node_modules/apache-arrow/src/builder.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from './vector.js';\nimport { Data, makeData } from './data.js';\nimport { MapRow, kKeys } from './row/map.js';\nimport {\n    DataType, strideForType,\n    Float, Int, Decimal, FixedSizeBinary,\n    Date_, Time, Timestamp, Interval,\n    Utf8, Binary, List, Map_,\n} from './type.js';\nimport { createIsValidFunction } from './builder/valid.js';\nimport { BufferBuilder, BitmapBufferBuilder, DataBufferBuilder, OffsetsBufferBuilder } from './builder/buffer.js';\n\n/**\n * A set of options required to create a `Builder` instance for a given `DataType`.\n * @see {@link Builder}\n */\nexport interface BuilderOptions<T extends DataType = any, TNull = any> {\n    type: T;\n    nullValues?: TNull[] | ReadonlyArray<TNull> | null;\n    children?: { [key: string]: BuilderOptions } | BuilderOptions[];\n}\n\n/**\n * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.\n *\n * A `Builder` is responsible for writing arbitrary JavaScript values\n * to ArrayBuffers and/or child Builders according to the Arrow specification\n * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.\n *\n * The `Builder` for each Arrow `DataType` handles converting and appending\n * values for a given `DataType`. The high-level {@link makeBuilder `makeBuilder()`} convenience\n * method creates the specific `Builder` subclass for the supplied `DataType`.\n *\n * Once created, `Builder` instances support both appending values to the end\n * of the `Builder`, and random-access writes to specific indices\n * (`Builder.prototype.append(value)` is a convenience method for\n * `builder.set(builder.length, value)`). Appending or setting values beyond the\n * Builder's current length may cause the builder to grow its underlying buffers\n * or child Builders (if applicable) to accommodate the new values.\n *\n * After enough values have been written to a `Builder`, `Builder.prototype.flush()`\n * will commit the values to the underlying ArrayBuffers (or child Builders). The\n * internal Builder state will be reset, and an instance of `Data<T>` is returned.\n * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return\n * an instance of `Vector<T>` instead.\n *\n * When there are no more values to write, use `Builder.prototype.finish()` to\n * finalize the `Builder`. This does not reset the internal state, so it is\n * necessary to call `Builder.prototype.flush()` or `toVector()` one last time\n * if there are still values queued to be flushed.\n *\n * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,\n * because this is when it flushes the values that have been enqueued in its internal\n * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.\n *\n * @example\n * ```ts\n * import { Builder, Utf8 } from 'apache-arrow';\n *\n * const utf8Builder = makeBuilder({\n *     type: new Utf8(),\n *     nullValues: [null, 'n/a']\n * });\n *\n * utf8Builder\n *     .append('hello')\n *     .append('n/a')\n *     .append('world')\n *     .append(null);\n *\n * const utf8Vector = utf8Builder.finish().toVector();\n *\n * console.log(utf8Vector.toJSON());\n * // > [\"hello\", null, \"world\", null]\n * ```\n *\n * @typeparam T The `DataType` of this `Builder`.\n * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n */\nexport abstract class Builder<T extends DataType = any, TNull = any> {\n\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughNode<T extends DataType = any, TNull = any>(options: import('./io/node/builder').BuilderDuplexOptions<T, TNull>): import('stream').Duplex {\n        throw new Error(`\"throughNode\" not available in this environment`);\n    }\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughDOM<T extends DataType = any, TNull = any>(options: import('./io/whatwg/builder').BuilderTransformOptions<T, TNull>): import('./io/whatwg/builder').BuilderTransform<T, TNull> {\n        throw new Error(`\"throughDOM\" not available in this environment`);\n    }\n\n    /**\n     * Construct a builder with the given Arrow DataType with optional null values,\n     * which will be interpreted as \"null\" when set or appended to the `Builder`.\n     * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\n     */\n    constructor({ 'type': type, 'nullValues': nulls }: BuilderOptions<T, TNull>) {\n        this.type = type;\n        this.children = [];\n        this.nullValues = nulls;\n        this.stride = strideForType(type);\n        this._nulls = new BitmapBufferBuilder();\n        if (nulls && nulls.length > 0) {\n            this._isValid = createIsValidFunction(nulls);\n        }\n    }\n\n    /**\n     * The Builder's `DataType` instance.\n     * @readonly\n     */\n    public type: T;\n    /**\n     * The number of values written to the `Builder` that haven't been flushed yet.\n     * @readonly\n     */\n    public length = 0;\n    /**\n     * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.\n     * @readonly\n     */\n    public finished = false;\n    /**\n     * The number of elements in the underlying values TypedArray that\n     * represent a single logical element, determined by this Builder's\n     * `DataType`. This is 1 for most types, but is larger when the `DataType`\n     * is `Int64`, `Uint64`, `Decimal`, `DateMillisecond`, certain variants of\n     * `Interval`, `Time`, or `Timestamp`, `FixedSizeBinary`, and `FixedSizeList`.\n     * @readonly\n     */\n    public readonly stride: number;\n    public readonly children: Builder[];\n    /**\n     * The list of null-value sentinels for this `Builder`. When one of these values\n     * is written to the `Builder` (either via `Builder.prototype.set()` or `Builder.prototype.append()`),\n     * a 1-bit is written to this Builder's underlying null BitmapBufferBuilder.\n     * @readonly\n     */\n    public readonly nullValues?: TNull[] | ReadonlyArray<TNull> | null;\n\n    /**\n     * Flush the `Builder` and return a `Vector<T>`.\n     * @returns {Vector<T>} A `Vector<T>` of the flushed values.\n     */\n    public toVector() { return new Vector([this.flush()]); }\n\n    public get ArrayType() { return this.type.ArrayType; }\n    public get nullCount() { return this._nulls.numInvalid; }\n    public get numChildren() { return this.children.length; }\n\n    /**\n     * @returns The aggregate length (in bytes) of the values that have been written.\n     */\n    public get byteLength(): number {\n        let size = 0;\n        const { _offsets, _values, _nulls, _typeIds, children } = this;\n        _offsets && (size += _offsets.byteLength);\n        _values && (size += _values.byteLength);\n        _nulls && (size += _nulls.byteLength);\n        _typeIds && (size += _typeIds.byteLength);\n        return children.reduce((size, child) => size + child.byteLength, size);\n    }\n\n    /**\n     * @returns The aggregate number of rows that have been reserved to write new values.\n     */\n    public get reservedLength(): number {\n        return this._nulls.reservedLength;\n    }\n\n    /**\n     * @returns The aggregate length (in bytes) that has been reserved to write new values.\n     */\n    public get reservedByteLength(): number {\n        let size = 0;\n        this._offsets && (size += this._offsets.reservedByteLength);\n        this._values && (size += this._values.reservedByteLength);\n        this._nulls && (size += this._nulls.reservedByteLength);\n        this._typeIds && (size += this._typeIds.reservedByteLength);\n        return this.children.reduce((size, child) => size + child.reservedByteLength, size);\n    }\n\n    declare protected _offsets: DataBufferBuilder<Int32Array>;\n    public get valueOffsets() { return this._offsets ? this._offsets.buffer : null; }\n\n    declare protected _values: BufferBuilder<T['TArray'], any>;\n    public get values() { return this._values ? this._values.buffer : null; }\n\n    declare protected _nulls: BitmapBufferBuilder;\n    public get nullBitmap() { return this._nulls ? this._nulls.buffer : null; }\n\n    declare protected _typeIds: DataBufferBuilder<Int8Array>;\n    public get typeIds() { return this._typeIds ? this._typeIds.buffer : null; }\n\n    declare protected _isValid: (value: T['TValue'] | TNull) => boolean;\n    declare protected _setValue: (inst: Builder<T>, index: number, value: T['TValue']) => void;\n\n    /**\n     * Appends a value (or null) to this `Builder`.\n     * This is equivalent to `builder.set(builder.length, value)`.\n     * @param {T['TValue'] | TNull } value The value to append.\n     */\n    public append(value: T['TValue'] | TNull) { return this.set(this.length, value); }\n\n    /**\n     * Validates whether a value is valid (true), or null (false)\n     * @param {T['TValue'] | TNull } value The value to compare against null the value representations\n     */\n    public isValid(value: T['TValue'] | TNull): boolean { return this._isValid(value); }\n\n    /**\n     * Write a value (or null-value sentinel) at the supplied index.\n     * If the value matches one of the null-value representations, a 1-bit is\n     * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\n     * the null `BitmapBufferBuilder`, and the value is passed to\n     * `Builder.prototype.setValue()`.\n     * @param {number} index The index of the value to write.\n     * @param {T['TValue'] | TNull } value The value to write at the supplied index.\n     * @returns {this} The updated `Builder` instance.\n     */\n    public set(index: number, value: T['TValue'] | TNull) {\n        if (this.setValid(index, this.isValid(value))) {\n            this.setValue(index, value);\n        }\n        return this;\n    }\n\n    /**\n     * Write a value to the underlying buffers at the supplied index, bypassing\n     * the null-value check. This is a low-level method that\n     * @param {number} index\n     * @param {T['TValue'] | TNull } value\n     */\n    public setValue(index: number, value: T['TValue']) { this._setValue(this, index, value); }\n    public setValid(index: number, valid: boolean) {\n        this.length = this._nulls.set(index, +valid).length;\n        return valid;\n    }\n\n    // @ts-ignore\n    public addChild(child: Builder, name = `${this.numChildren}`) {\n        throw new Error(`Cannot append children to non-nested type \"${this.type}\"`);\n    }\n\n    /**\n     * Retrieve the child `Builder` at the supplied `index`, or null if no child\n     * exists at that index.\n     * @param {number} index The index of the child `Builder` to retrieve.\n     * @returns {Builder | null} The child Builder at the supplied index or null.\n     */\n    public getChildAt<R extends DataType = any>(index: number): Builder<R> | null {\n        return this.children[index] || null;\n    }\n\n    /**\n     * Commit all the values that have been written to their underlying\n     * ArrayBuffers, including any child Builders if applicable, and reset\n     * the internal `Builder` state.\n     * @returns A `Data<T>` of the buffers and children representing the values written.\n     */\n    public flush(): Data<T> {\n\n        let data;\n        let typeIds;\n        let nullBitmap;\n        let valueOffsets;\n        const { type, length, nullCount, _typeIds, _offsets, _values, _nulls } = this;\n\n        if (typeIds = _typeIds?.flush(length)) { // Unions\n            // DenseUnions\n            valueOffsets = _offsets?.flush(length);\n        } else if (valueOffsets = _offsets?.flush(length)) { // Variable-width primitives (Binary, Utf8), and Lists\n            // Binary, Utf8\n            data = _values?.flush(_offsets.last());\n        } else { // Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, and Interval)\n            data = _values?.flush(length);\n        }\n\n        if (nullCount > 0) {\n            nullBitmap = _nulls?.flush(length);\n        }\n\n        const children = this.children.map((child) => child.flush());\n\n        this.clear();\n\n        return makeData(<any>{\n            type, length, nullCount,\n            children, 'child': children[0],\n            data, typeIds, nullBitmap, valueOffsets,\n        }) as Data<T>;\n    }\n\n    /**\n     * Finalize this `Builder`, and child builders if applicable.\n     * @returns {this} The finalized `Builder` instance.\n     */\n    public finish() {\n        this.finished = true;\n        for (const child of this.children) child.finish();\n        return this;\n    }\n\n    /**\n     * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\n     * @returns {this} The cleared `Builder` instance.\n     */\n    public clear() {\n        this.length = 0;\n        this._nulls?.clear();\n        this._values?.clear();\n        this._offsets?.clear();\n        this._typeIds?.clear();\n        for (const child of this.children) child.clear();\n        return this;\n    }\n}\n\n(Builder.prototype as any).length = 1;\n(Builder.prototype as any).stride = 1;\n(Builder.prototype as any).children = null;\n(Builder.prototype as any).finished = false;\n(Builder.prototype as any).nullValues = null;\n(Builder.prototype as any)._isValid = () => true;\n\n/** @ignore */\nexport abstract class FixedWidthBuilder<T extends Int | Float | FixedSizeBinary | Date_ | Timestamp | Time | Decimal | Interval = any, TNull = any> extends Builder<T, TNull> {\n    constructor(opts: BuilderOptions<T, TNull>) {\n        super(opts);\n        this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);\n    }\n    public setValue(index: number, value: T['TValue']) {\n        const values = this._values;\n        values.reserve(index - values.length + 1);\n        return super.setValue(index, value);\n    }\n}\n\n/** @ignore */\nexport abstract class VariableWidthBuilder<T extends Binary | Utf8 | List | Map_, TNull = any> extends Builder<T, TNull> {\n    protected _pendingLength = 0;\n    protected _offsets: OffsetsBufferBuilder;\n    protected _pending: Map<number, any> | undefined;\n    constructor(opts: BuilderOptions<T, TNull>) {\n        super(opts);\n        this._offsets = new OffsetsBufferBuilder();\n    }\n    public setValue(index: number, value: T['TValue']) {\n        const pending = this._pending || (this._pending = new Map());\n        const current = pending.get(index);\n        current && (this._pendingLength -= current.length);\n        this._pendingLength += (value instanceof MapRow) ? value[kKeys].length : value.length;\n        pending.set(index, value);\n    }\n    public setValid(index: number, isValid: boolean) {\n        if (!super.setValid(index, isValid)) {\n            (this._pending || (this._pending = new Map())).set(index, undefined);\n            return false;\n        }\n        return true;\n    }\n    public clear() {\n        this._pendingLength = 0;\n        this._pending = undefined;\n        return super.clear();\n    }\n    public flush() {\n        this._flush();\n        return super.flush();\n    }\n    public finish() {\n        this._flush();\n        return super.finish();\n    }\n    protected _flush() {\n        const pending = this._pending;\n        const pendingLength = this._pendingLength;\n        this._pendingLength = 0;\n        this._pending = undefined;\n        if (pending && pending.size > 0) {\n            this._flushPending(pending, pendingLength);\n        }\n        return this;\n    }\n    protected abstract _flushPending(pending: Map<number, any>, pendingLength: number): void;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}