{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { DictionaryEncoding } from './dictionary-encoding.mjs';\nimport { KeyValue } from './key-value.mjs';\nimport { Type } from './type.mjs';\n/**\n * ----------------------------------------------------------------------\n * A field represents a named column in a record / row batch or child of a\n * nested type.\n */\nexport class Field {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb) {\n    this.bb_pos = i;\n    this.bb = bb;\n    return this;\n  }\n  static getRootAsField(bb, obj) {\n    return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  static getSizePrefixedRootAsField(bb, obj) {\n    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n    return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  name(optionalEncoding) {\n    const offset = this.bb.__offset(this.bb_pos, 4);\n    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n  }\n  /**\n   * Whether or not this field can contain nulls. Should be true in general.\n   */\n  nullable() {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n  }\n  typeType() {\n    const offset = this.bb.__offset(this.bb_pos, 8);\n    return offset ? this.bb.readUint8(this.bb_pos + offset) : Type.NONE;\n  }\n  /**\n   * This is the type of the decoded value if the field is dictionary encoded.\n   */\n  // @ts-ignore\n  type(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 10);\n    return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;\n  }\n  /**\n   * Present only if the field is dictionary encoded.\n   */\n  dictionary(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 12);\n    return offset ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n  }\n  /**\n   * children apply only to nested data types like Struct, List and Union. For\n   * primitive types children will have length 0.\n   */\n  children(index, obj) {\n    const offset = this.bb.__offset(this.bb_pos, 14);\n    return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n  }\n  childrenLength() {\n    const offset = this.bb.__offset(this.bb_pos, 14);\n    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n  }\n  /**\n   * User-defined metadata\n   */\n  customMetadata(index, obj) {\n    const offset = this.bb.__offset(this.bb_pos, 16);\n    return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset = this.bb.__offset(this.bb_pos, 16);\n    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n  }\n  static startField(builder) {\n    builder.startObject(7);\n  }\n  static addName(builder, nameOffset) {\n    builder.addFieldOffset(0, nameOffset, 0);\n  }\n  static addNullable(builder, nullable) {\n    builder.addFieldInt8(1, +nullable, +false);\n  }\n  static addTypeType(builder, typeType) {\n    builder.addFieldInt8(2, typeType, Type.NONE);\n  }\n  static addType(builder, typeOffset) {\n    builder.addFieldOffset(3, typeOffset, 0);\n  }\n  static addDictionary(builder, dictionaryOffset) {\n    builder.addFieldOffset(4, dictionaryOffset, 0);\n  }\n  static addChildren(builder, childrenOffset) {\n    builder.addFieldOffset(5, childrenOffset, 0);\n  }\n  static createChildrenVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startChildrenVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(6, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endField(builder) {\n    const offset = builder.endObject();\n    return offset;\n  }\n}","map":{"version":3,"names":["flatbuffers","DictionaryEncoding","KeyValue","Type","Field","constructor","bb","bb_pos","__init","i","getRootAsField","obj","readInt32","position","getSizePrefixedRootAsField","setPosition","SIZE_PREFIX_LENGTH","name","optionalEncoding","offset","__offset","__string","nullable","readInt8","typeType","readUint8","NONE","type","__union","dictionary","__indirect","children","index","__vector","childrenLength","__vector_len","customMetadata","customMetadataLength","startField","builder","startObject","addName","nameOffset","addFieldOffset","addNullable","addFieldInt8","addTypeType","addType","typeOffset","addDictionary","dictionaryOffset","addChildren","childrenOffset","createChildrenVector","data","startVector","length","addOffset","endVector","startChildrenVector","numElems","addCustomMetadata","customMetadataOffset","createCustomMetadataVector","startCustomMetadataVector","endField","endObject"],"sources":["/Users/lfoppiano/development/projects/streamlit-pdf-component/my_component/frontend/node_modules/apache-arrow/src/fb/field.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { DictionaryEncoding } from './dictionary-encoding.js';\nimport { KeyValue } from './key-value.js';\nimport { Type } from './type.js';\n\n\n/**\n * ----------------------------------------------------------------------\n * A field represents a named column in a record / row batch or child of a\n * nested type.\n */\nexport class Field {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):Field {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsField(bb:flatbuffers.ByteBuffer, obj?:Field):Field {\n  return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsField(bb:flatbuffers.ByteBuffer, obj?:Field):Field {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\n/**\n * Name is not required, in i.e. a List\n */\nname():string|null\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\nname(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\n/**\n * Whether or not this field can contain nulls. Should be true in general.\n */\nnullable():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\ntypeType():Type {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : Type.NONE;\n}\n\n/**\n * This is the type of the decoded value if the field is dictionary encoded.\n */\n// @ts-ignore\ntype<T extends flatbuffers.Table>(obj:any):any|null {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\n}\n\n/**\n * Present only if the field is dictionary encoded.\n */\ndictionary(obj?:DictionaryEncoding):DictionaryEncoding|null {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? (obj || new DictionaryEncoding()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\n/**\n * children apply only to nested data types like Struct, List and Union. For\n * primitive types children will have length 0.\n */\nchildren(index: number, obj?:Field):Field|null {\n  const offset = this.bb!.__offset(this.bb_pos, 14);\n  return offset ? (obj || new Field()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\n}\n\nchildrenLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 14);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\n/**\n * User-defined metadata\n */\ncustomMetadata(index: number, obj?:KeyValue):KeyValue|null {\n  const offset = this.bb!.__offset(this.bb_pos, 16);\n  return offset ? (obj || new KeyValue()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\n}\n\ncustomMetadataLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 16);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\nstatic startField(builder:flatbuffers.Builder) {\n  builder.startObject(7);\n}\n\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(0, nameOffset, 0);\n}\n\nstatic addNullable(builder:flatbuffers.Builder, nullable:boolean) {\n  builder.addFieldInt8(1, +nullable, +false);\n}\n\nstatic addTypeType(builder:flatbuffers.Builder, typeType:Type) {\n  builder.addFieldInt8(2, typeType, Type.NONE);\n}\n\nstatic addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(3, typeOffset, 0);\n}\n\nstatic addDictionary(builder:flatbuffers.Builder, dictionaryOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(4, dictionaryOffset, 0);\n}\n\nstatic addChildren(builder:flatbuffers.Builder, childrenOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(5, childrenOffset, 0);\n}\n\nstatic createChildrenVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\n  builder.startVector(4, data.length, 4);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addOffset(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startChildrenVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(4, numElems, 4);\n}\n\nstatic addCustomMetadata(builder:flatbuffers.Builder, customMetadataOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(6, customMetadataOffset, 0);\n}\n\nstatic createCustomMetadataVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\n  builder.startVector(4, data.length, 4);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addOffset(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startCustomMetadataVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(4, numElems, 4);\n}\n\nstatic endField(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  return offset;\n}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}