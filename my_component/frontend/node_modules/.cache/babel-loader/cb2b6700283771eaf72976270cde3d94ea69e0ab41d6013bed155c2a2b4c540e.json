{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Type } from './enum.mjs';\nimport { Data, makeData } from './data.mjs';\nimport { vectorFromArray } from './factories.mjs';\nimport { makeVector, Vector } from './vector.mjs';\nimport { Field, Schema } from './schema.mjs';\nimport { Null, Struct } from './type.mjs';\nimport { compareSchemas } from './visitor/typecomparator.mjs';\nimport { distributeVectorsIntoRecordBatches } from './util/recordbatch.mjs';\nimport { isChunkedValid, computeChunkOffsets, computeChunkNullCounts, wrapChunkedCall1, wrapChunkedCall2, wrapChunkedIndexOf, sliceChunks } from './util/chunk.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.mjs';\nimport { clampRange } from './util/vector.mjs';\nimport { RecordBatch } from './recordbatch.mjs';\n/**\n * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}\n * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use\n * {@link tableFromIPC}.\n */\nexport class Table {\n  constructor(...args) {\n    var _b, _c;\n    if (args.length === 0) {\n      this.batches = [];\n      this.schema = new Schema([]);\n      this._offsets = [0];\n      return this;\n    }\n    let schema;\n    let offsets;\n    if (args[0] instanceof Schema) {\n      schema = args.shift();\n    }\n    if (args[args.length - 1] instanceof Uint32Array) {\n      offsets = args.pop();\n    }\n    const unwrap = x => {\n      if (x) {\n        if (x instanceof RecordBatch) {\n          return [x];\n        } else if (x instanceof Table) {\n          return x.batches;\n        } else if (x instanceof Data) {\n          if (x.type instanceof Struct) {\n            return [new RecordBatch(new Schema(x.type.children), x)];\n          }\n        } else if (Array.isArray(x)) {\n          return x.flatMap(v => unwrap(v));\n        } else if (typeof x[Symbol.iterator] === 'function') {\n          return [...x].flatMap(v => unwrap(v));\n        } else if (typeof x === 'object') {\n          const keys = Object.keys(x);\n          const vecs = keys.map(k => new Vector([x[k]]));\n          const schema = new Schema(keys.map((k, i) => new Field(String(k), vecs[i].type)));\n          const [, batches] = distributeVectorsIntoRecordBatches(schema, vecs);\n          return batches.length === 0 ? [new RecordBatch(x)] : batches;\n        }\n      }\n      return [];\n    };\n    const batches = args.flatMap(v => unwrap(v));\n    schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new Schema([]);\n    if (!(schema instanceof Schema)) {\n      throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n    }\n    for (const batch of batches) {\n      if (!(batch instanceof RecordBatch)) {\n        throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n      }\n      if (!compareSchemas(schema, batch.schema)) {\n        throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');\n      }\n    }\n    this.schema = schema;\n    this.batches = batches;\n    this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);\n  }\n  /**\n   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n   */\n  get data() {\n    return this.batches.map(({\n      data\n    }) => data);\n  }\n  /**\n   * The number of columns in this Table.\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\n   * The number of rows in this Table.\n   */\n  get numRows() {\n    return this.data.reduce((numRows, data) => numRows + data.length, 0);\n  }\n  /**\n   * The number of null rows in this Table.\n   */\n  get nullCount() {\n    if (this._nullCount === -1) {\n      this._nullCount = computeChunkNullCounts(this.data);\n    }\n    return this._nullCount;\n  }\n  /**\n   * Check whether an element is null.\n   *\n   * @param index The index at which to read the validity bitmap.\n   */\n  // @ts-ignore\n  isValid(index) {\n    return false;\n  }\n  /**\n   * Get an element value by position.\n   *\n   * @param index The index of the element to read.\n   */\n  // @ts-ignore\n  get(index) {\n    return null;\n  }\n  /**\n   * Set an element value by position.\n   *\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  // @ts-ignore\n  set(index, value) {\n    return;\n  }\n  /**\n   * Retrieve the index of the first occurrence of a value in an Vector.\n   *\n   * @param element The value to locate in the Vector.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  // @ts-ignore\n  indexOf(element, offset) {\n    return -1;\n  }\n  /**\n   * Get the size in bytes of an element by index.\n   * @param index The index at which to get the byteLength.\n   */\n  // @ts-ignore\n  getByteLength(index) {\n    return 0;\n  }\n  /**\n   * Iterator for rows in this Table.\n   */\n  [Symbol.iterator]() {\n    if (this.batches.length > 0) {\n      return iteratorVisitor.visit(new Vector(this.data));\n    }\n    return new Array(0)[Symbol.iterator]();\n  }\n  /**\n   * Return a JavaScript Array of the Table rows.\n   *\n   * @returns An Array of Table rows.\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\n   * Returns a string representation of the Table rows.\n   *\n   * @returns A string representation of the Table rows.\n   */\n  toString() {\n    return `[\\n  ${this.toArray().join(',\\n  ')}\\n]`;\n  }\n  /**\n   * Combines two or more Tables of the same schema.\n   *\n   * @param others Additional Tables to add to the end of this Tables.\n   */\n  concat(...others) {\n    const schema = this.schema;\n    const data = this.data.concat(others.flatMap(({\n      data\n    }) => data));\n    return new Table(schema, data.map(data => new RecordBatch(schema, data)));\n  }\n  /**\n   * Return a zero-copy sub-section of this Table.\n   *\n   * @param begin The beginning of the specified portion of the Table.\n   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    const schema = this.schema;\n    [begin, end] = clampRange({\n      length: this.numRows\n    }, begin, end);\n    const data = sliceChunks(this.data, this._offsets, begin, end);\n    return new Table(schema, data.map(chunk => new RecordBatch(schema, chunk)));\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   *\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    return this.getChildAt(this.schema.fields.findIndex(f => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   *\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index) {\n    if (index > -1 && index < this.schema.fields.length) {\n      const data = this.data.map(data => data.children[index]);\n      if (data.length === 0) {\n        const {\n          type\n        } = this.schema.fields[index];\n        const empty = makeData({\n          type,\n          length: 0,\n          nullCount: 0\n        });\n        data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));\n      }\n      return new Vector(data);\n    }\n    return null;\n  }\n  /**\n   * Sets a child Vector by name.\n   *\n   * @param name The name of the child to overwrite.\n   * @returns A new Table with the supplied child for the specified name.\n   */\n  setChild(name, child) {\n    var _b;\n    return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex(f => f.name === name), child);\n  }\n  setChildAt(index, child) {\n    let schema = this.schema;\n    let batches = [...this.batches];\n    if (index > -1 && index < this.numCols) {\n      if (!child) {\n        child = new Vector([makeData({\n          type: new Null(),\n          length: this.numRows\n        })]);\n      }\n      const fields = schema.fields.slice();\n      const field = fields[index].clone({\n        type: child.type\n      });\n      const children = this.schema.fields.map((_, i) => this.getChildAt(i));\n      [fields[index], children[index]] = [field, child];\n      [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);\n    }\n    return new Table(schema, batches);\n  }\n  /**\n   * Construct a new Table containing only specified columns.\n   *\n   * @param columnNames Names of columns to keep.\n   * @returns A new Table of columns matching the specified names.\n   */\n  select(columnNames) {\n    const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map());\n    return this.selectAt(columnNames.map(columnName => nameToIndex.get(columnName)).filter(x => x > -1));\n  }\n  /**\n   * Construct a new Table containing only columns at the specified indices.\n   *\n   * @param columnIndices Indices of columns to keep.\n   * @returns A new Table of columns at the specified indices.\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const data = this.batches.map(batch => batch.selectAt(columnIndices));\n    return new Table(schema, data);\n  }\n  assign(other) {\n    const fields = this.schema.fields;\n    const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\n      const [indices, oldToNew] = memo;\n      const i = fields.findIndex(f => f.name === f2.name);\n      ~i ? oldToNew[i] = newIdx : indices.push(newIdx);\n      return memo;\n    }, [[], []]);\n    const schema = this.schema.assign(other.schema);\n    const columns = [...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => j === undefined ? this.getChildAt(i) : other.getChildAt(j)), ...indices.map(i => other.getChildAt(i))].filter(Boolean);\n    return new Table(...distributeVectorsIntoRecordBatches(schema, columns));\n  }\n}\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nTable[_a] = (proto => {\n  proto.schema = null;\n  proto.batches = [];\n  proto._offsets = new Uint32Array([0]);\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  proto['isValid'] = wrapChunkedCall1(isChunkedValid);\n  proto['get'] = wrapChunkedCall1(getVisitor.getVisitFn(Type.Struct));\n  proto['set'] = wrapChunkedCall2(setVisitor.getVisitFn(Type.Struct));\n  proto['indexOf'] = wrapChunkedIndexOf(indexOfVisitor.getVisitFn(Type.Struct));\n  proto['getByteLength'] = wrapChunkedCall1(byteLengthVisitor.getVisitFn(Type.Struct));\n  return 'Table';\n})(Table.prototype);\n/**\n * Creates a new Table from an object of typed arrays.\n *\n*  @example\n * ```ts\n * const table = makeTable({\n *   a: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays.\n * @returns A new Table.\n */\nexport function makeTable(input) {\n  const vecs = {};\n  const inputs = Object.entries(input);\n  for (const [key, col] of inputs) {\n    vecs[key] = makeVector(col);\n  }\n  return new Table(vecs);\n}\n/**\n * Creates a new Table from an object of typed arrays or JavaScript arrays.\n *\n *  @example\n * ```ts\n * const table = tableFromArrays({\n *   a: [1, 2, 3],\n *   b: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays or JavaScript arrays.\n * @returns A new Table.\n */\nexport function tableFromArrays(input) {\n  const vecs = {};\n  const inputs = Object.entries(input);\n  for (const [key, col] of inputs) {\n    vecs[key] = vectorFromArray(col);\n  }\n  return new Table(vecs);\n}","map":{"version":3,"names":["Type","Data","makeData","vectorFromArray","makeVector","Vector","Field","Schema","Null","Struct","compareSchemas","distributeVectorsIntoRecordBatches","isChunkedValid","computeChunkOffsets","computeChunkNullCounts","wrapChunkedCall1","wrapChunkedCall2","wrapChunkedIndexOf","sliceChunks","instance","getVisitor","setVisitor","indexOfVisitor","iteratorVisitor","byteLengthVisitor","clampRange","RecordBatch","Table","constructor","args","length","batches","schema","_offsets","offsets","shift","Uint32Array","pop","unwrap","x","type","children","Array","isArray","flatMap","v","Symbol","iterator","keys","Object","vecs","map","k","i","String","_c","_b","TypeError","batch","data","numCols","fields","numRows","reduce","nullCount","_nullCount","isValid","index","get","set","value","indexOf","element","offset","getByteLength","visit","toArray","toString","join","concat","others","slice","begin","end","chunk","getChild","name","getChildAt","findIndex","f","empty","push","_changeLengthAndBackfillNullBitmap","setChild","child","setChildAt","field","clone","_","select","columnNames","nameToIndex","m","Map","selectAt","columnName","filter","columnIndices","assign","other","indices","oldToNew","memo","f2","newIdx","columns","j","undefined","Boolean","toStringTag","_a","proto","isConcatSpreadable","getVisitFn","prototype","makeTable","input","inputs","entries","key","col","tableFromArrays"],"sources":["/Users/lfoppiano/development/projects/streamlit-pdf-component/my_component/frontend/node_modules/apache-arrow/src/table.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Type } from './enum.js';\nimport { Data, makeData } from './data.js';\nimport { vectorFromArray } from './factories.js';\nimport { makeVector, Vector } from './vector.js';\nimport { Field, Schema } from './schema.js';\nimport { DataType, Null, Struct, TypeMap } from './type.js';\nimport { compareSchemas } from './visitor/typecomparator.js';\nimport { distributeVectorsIntoRecordBatches } from './util/recordbatch.js';\n\nimport {\n    isChunkedValid,\n    computeChunkOffsets,\n    computeChunkNullCounts,\n    wrapChunkedCall1,\n    wrapChunkedCall2,\n    wrapChunkedIndexOf,\n    sliceChunks,\n} from './util/chunk.js';\n\nimport { instance as getVisitor } from './visitor/get.js';\nimport { instance as setVisitor } from './visitor/set.js';\nimport { instance as indexOfVisitor } from './visitor/indexof.js';\nimport { instance as iteratorVisitor } from './visitor/iterator.js';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.js';\n\nimport { DataProps } from './data.js';\nimport { clampRange } from './util/vector.js';\nimport { ArrayDataType, BigIntArray, TypedArray, TypedArrayDataType } from './interfaces.js';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from './recordbatch.js';\n\n/** @ignore */\nexport interface Table<T extends TypeMap = any> {\n    ///\n    // Virtual properties for the TypeScript compiler.\n    // These do not exist at runtime.\n    ///\n    readonly TType: Struct<T>;\n    readonly TArray: Struct<T>['TArray'];\n    readonly TValue: Struct<T>['TValue'];\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable\n     */\n    [Symbol.isConcatSpreadable]: true;\n}\n\n/**\n * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}\n * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use\n * {@link tableFromIPC}.\n */\nexport class Table<T extends TypeMap = any> {\n\n    constructor();\n    constructor(batches: Iterable<RecordBatch<T>>);\n    constructor(...batches: readonly RecordBatch<T>[]);\n    constructor(...columns: { [P in keyof T]: Vector<T[P]> }[]);\n    constructor(...columns: { [P in keyof T]: Data<T[P]> | DataProps<T[P]> }[]);\n    constructor(schema: Schema<T>, data?: RecordBatch<T> | RecordBatch<T>[]);\n    constructor(schema: Schema<T>, data?: RecordBatch<T> | RecordBatch<T>[], offsets?: Uint32Array);\n    constructor(...args: any[]) {\n\n        if (args.length === 0) {\n            this.batches = [];\n            this.schema = new Schema([]);\n            this._offsets = [0];\n            return this;\n        }\n\n        let schema: Schema<T> | undefined;\n        let offsets: Uint32Array | number[] | undefined;\n\n        if (args[0] instanceof Schema) {\n            schema = args.shift() as Schema<T>;\n        }\n\n        if (args[args.length - 1] instanceof Uint32Array) {\n            offsets = args.pop();\n        }\n\n        const unwrap = (x: any): RecordBatch<T>[] => {\n            if (x) {\n                if (x instanceof RecordBatch) {\n                    return [x];\n                } else if (x instanceof Table) {\n                    return x.batches;\n                } else if (x instanceof Data) {\n                    if (x.type instanceof Struct) {\n                        return [new RecordBatch(new Schema(x.type.children), x)];\n                    }\n                } else if (Array.isArray(x)) {\n                    return x.flatMap(v => unwrap(v));\n                } else if (typeof x[Symbol.iterator] === 'function') {\n                    return [...x].flatMap(v => unwrap(v));\n                } else if (typeof x === 'object') {\n                    const keys = Object.keys(x) as (keyof T)[];\n                    const vecs = keys.map((k) => new Vector([x[k]]));\n                    const schema = new Schema(keys.map((k, i) => new Field(String(k), vecs[i].type)));\n                    const [, batches] = distributeVectorsIntoRecordBatches(schema, vecs);\n                    return batches.length === 0 ? [new RecordBatch(x)] : batches;\n                }\n            }\n            return [];\n        };\n\n        const batches = args.flatMap(v => unwrap(v));\n\n        schema = schema ?? batches[0]?.schema ?? new Schema([]);\n\n        if (!(schema instanceof Schema)) {\n            throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n        }\n\n        for (const batch of batches) {\n            if (!(batch instanceof RecordBatch)) {\n                throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n            }\n            if (!compareSchemas(schema, batch.schema)) {\n                throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');\n            }\n        }\n\n        this.schema = schema;\n        this.batches = batches;\n        this._offsets = offsets ?? computeChunkOffsets(this.data);\n    }\n\n    declare protected _offsets: Uint32Array | number[];\n    declare protected _nullCount: number;\n\n    declare public readonly schema: Schema<T>;\n\n    /**\n     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n     */\n    declare public readonly batches: RecordBatch<T>[];\n\n    /**\n     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n     */\n    public get data() { return this.batches.map(({ data }) => data); }\n\n    /**\n     * The number of columns in this Table.\n     */\n    public get numCols() { return this.schema.fields.length; }\n\n    /**\n     * The number of rows in this Table.\n     */\n    public get numRows() {\n        return this.data.reduce((numRows, data) => numRows + data.length, 0);\n    }\n\n    /**\n     * The number of null rows in this Table.\n     */\n    public get nullCount() {\n        if (this._nullCount === -1) {\n            this._nullCount = computeChunkNullCounts(this.data);\n        }\n        return this._nullCount;\n    }\n\n    /**\n     * Check whether an element is null.\n     *\n     * @param index The index at which to read the validity bitmap.\n     */\n    // @ts-ignore\n    public isValid(index: number): boolean { return false; }\n\n    /**\n     * Get an element value by position.\n     *\n     * @param index The index of the element to read.\n     */\n    // @ts-ignore\n    public get(index: number): Struct<T>['TValue'] | null { return null; }\n\n    /**\n     * Set an element value by position.\n     *\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    // @ts-ignore\n    public set(index: number, value: Struct<T>['TValue'] | null): void { return; }\n\n    /**\n     * Retrieve the index of the first occurrence of a value in an Vector.\n     *\n     * @param element The value to locate in the Vector.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    // @ts-ignore\n    public indexOf(element: Struct<T>['TValue'], offset?: number): number { return -1; }\n\n    /**\n     * Get the size in bytes of an element by index.\n     * @param index The index at which to get the byteLength.\n     */\n    // @ts-ignore\n    public getByteLength(index: number): number { return 0; }\n\n    /**\n     * Iterator for rows in this Table.\n     */\n    public [Symbol.iterator]() {\n        if (this.batches.length > 0) {\n            return iteratorVisitor.visit(new Vector(this.data)) as IterableIterator<Struct<T>['TValue']>;\n        }\n        return (new Array(0))[Symbol.iterator]();\n    }\n\n    /**\n     * Return a JavaScript Array of the Table rows.\n     *\n     * @returns An Array of Table rows.\n     */\n    public toArray() {\n        return [...this];\n    }\n\n    /**\n     * Returns a string representation of the Table rows.\n     *\n     * @returns A string representation of the Table rows.\n     */\n    public toString() {\n        return `[\\n  ${this.toArray().join(',\\n  ')}\\n]`;\n    }\n\n    /**\n     * Combines two or more Tables of the same schema.\n     *\n     * @param others Additional Tables to add to the end of this Tables.\n     */\n    public concat(...others: Table<T>[]) {\n        const schema = this.schema;\n        const data = this.data.concat(others.flatMap(({ data }) => data));\n        return new Table(schema, data.map((data) => new RecordBatch(schema, data)));\n    }\n\n    /**\n     * Return a zero-copy sub-section of this Table.\n     *\n     * @param begin The beginning of the specified portion of the Table.\n     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\n     */\n    public slice(begin?: number, end?: number): Table<T> {\n        const schema = this.schema;\n        [begin, end] = clampRange({ length: this.numRows }, begin, end);\n        const data = sliceChunks(this.data, this._offsets, begin, end);\n        return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));\n    }\n\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     *\n     * @param name The name of the child to retrieve.\n     */\n    public getChild<P extends keyof T>(name: P) {\n        return this.getChildAt<T[P]>(this.schema.fields.findIndex((f) => f.name === name));\n    }\n\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     *\n     * @param index The index of the child to retrieve.\n     */\n    public getChildAt<R extends T[keyof T] = any>(index: number): Vector<R> | null {\n        if (index > -1 && index < this.schema.fields.length) {\n            const data = this.data.map((data) => data.children[index] as Data<R>);\n            if (data.length === 0) {\n                const { type } = this.schema.fields[index] as Field<R>;\n                const empty = makeData<R>({ type, length: 0, nullCount: 0 });\n                data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));\n            }\n            return new Vector(data);\n        }\n        return null;\n    }\n\n    /**\n     * Sets a child Vector by name.\n     *\n     * @param name The name of the child to overwrite.\n     * @returns A new Table with the supplied child for the specified name.\n     */\n    public setChild<P extends keyof T, R extends DataType>(name: P, child: Vector<R>) {\n        return this.setChildAt(this.schema.fields?.findIndex((f) => f.name === name), child) as Table<T & { [K in P]: R }>;\n    }\n\n    /**\n     * Sets a child Vector by index.\n     *\n     * @param index The index of the child to overwrite.\n     * @returns A new Table with the supplied child at the specified index.\n     */\n    public setChildAt(index: number, child?: null): Table;\n    public setChildAt<R extends DataType = any>(index: number, child: Vector<R>): Table;\n    public setChildAt(index: number, child: any) {\n        let schema: Schema = this.schema;\n        let batches: RecordBatch[] = [...this.batches];\n        if (index > -1 && index < this.numCols) {\n            if (!child) {\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\n            }\n            const fields = schema.fields.slice() as Field<any>[];\n            const field = fields[index].clone({ type: child.type });\n            const children = this.schema.fields.map((_, i) => this.getChildAt(i)!);\n            [fields[index], children[index]] = [field, child];\n            [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);\n        }\n        return new Table(schema, batches);\n    }\n\n    /**\n     * Construct a new Table containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new Table of columns matching the specified names.\n     */\n    public select<K extends keyof T = any>(columnNames: K[]) {\n        const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name as K, i), new Map<K, number>());\n        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)!).filter((x) => x > -1));\n    }\n\n    /**\n     * Construct a new Table containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new Table of columns at the specified indices.\n     */\n    public selectAt<K extends T[keyof T] = any>(columnIndices: number[]) {\n        const schema = this.schema.selectAt(columnIndices);\n        const data = this.batches.map((batch) => batch.selectAt(columnIndices));\n        return new Table<{ [key: string]: K }>(schema, data);\n    }\n\n    public assign<R extends TypeMap = any>(other: Table<R>) {\n\n        const fields = this.schema.fields;\n        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\n            const [indices, oldToNew] = memo;\n            const i = fields.findIndex((f) => f.name === f2.name);\n            ~i ? (oldToNew[i] = newIdx) : indices.push(newIdx);\n            return memo;\n        }, [[], []] as number[][]);\n\n        const schema = this.schema.assign(other.schema);\n        const columns = [\n            ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) =>\n                (j === undefined ? this.getChildAt(i) : other.getChildAt(j))!),\n            ...indices.map((i) => other.getChildAt(i)!)\n        ].filter(Boolean) as Vector<(T & R)[keyof T | keyof R]>[];\n\n        return new Table<T & R>(...distributeVectorsIntoRecordBatches<any>(schema, columns));\n    }\n\n    // Initialize this static property via an IIFE so bundlers don't tree-shake\n    // out this logic, but also so we're still compliant with `\"sideEffects\": false`\n    protected static [Symbol.toStringTag] = ((proto: Table) => {\n        (proto as any).schema = null;\n        (proto as any).batches = [];\n        (proto as any)._offsets = new Uint32Array([0]);\n        (proto as any)._nullCount = -1;\n        (proto as any)[Symbol.isConcatSpreadable] = true;\n        (proto as any)['isValid'] = wrapChunkedCall1(isChunkedValid);\n        (proto as any)['get'] = wrapChunkedCall1(getVisitor.getVisitFn(Type.Struct));\n        (proto as any)['set'] = wrapChunkedCall2(setVisitor.getVisitFn(Type.Struct));\n        (proto as any)['indexOf'] = wrapChunkedIndexOf(indexOfVisitor.getVisitFn(Type.Struct));\n        (proto as any)['getByteLength'] = wrapChunkedCall1(byteLengthVisitor.getVisitFn(Type.Struct));\n        return 'Table';\n    })(Table.prototype);\n}\n\n\ntype VectorsMap<T extends TypeMap> = { [P in keyof T]: Vector<T[P]> };\n\n/**\n * Creates a new Table from an object of typed arrays.\n *\n*  @example\n * ```ts\n * const table = makeTable({\n *   a: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays.\n * @returns A new Table.\n */\nexport function makeTable<I extends Record<string | number | symbol, TypedArray>>(input: I): Table<{ [P in keyof I]: TypedArrayDataType<I[P]> }> {\n    type T = { [P in keyof I]: TypedArrayDataType<I[P]> };\n    const vecs = {} as VectorsMap<T>;\n    const inputs = Object.entries(input) as [keyof I, I[keyof I]][];\n    for (const [key, col] of inputs) {\n        vecs[key] = makeVector(col);\n    }\n    return new Table<T>(vecs);\n}\n\n/**\n * Creates a new Table from an object of typed arrays or JavaScript arrays.\n *\n *  @example\n * ```ts\n * const table = tableFromArrays({\n *   a: [1, 2, 3],\n *   b: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays or JavaScript arrays.\n * @returns A new Table.\n */\nexport function tableFromArrays<I extends Record<string | number | symbol, TypedArray | BigIntArray | readonly unknown[]>>(input: I): Table<{ [P in keyof I]: ArrayDataType<I[P]> }> {\n    type T = { [P in keyof I]: ArrayDataType<I[P]> };\n    const vecs = {} as VectorsMap<T>;\n    const inputs = Object.entries(input) as [keyof I, I[keyof I]][];\n    for (const [key, col] of inputs) {\n        vecs[key] = vectorFromArray(col);\n    }\n    return new Table<T>(vecs);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}